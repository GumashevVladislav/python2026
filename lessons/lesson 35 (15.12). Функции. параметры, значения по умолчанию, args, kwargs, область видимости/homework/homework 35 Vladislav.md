# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи
1.  **Функция для расчета стоимости доставки**
    -   **Описание задачи:** Ты пишешь модуль для интернет-магазина. Нужно создать функцию, которая рассчитывает стоимость доставки. Функция должна принимать обязательные параметры (вес и город) и иметь параметр со значением по умолчанию для срочной доставки. Это упражнение закрепляет навыки объявления функций, передачи позиционных и именованных аргументов, использования `return` и значений по умолчанию.
    -   **Пример (вход → выход):**
        -   `calculate_delivery(5, "Москва")` → `400` (стандартная доставка: 300 + 20*5)
        -   `calculate_delivery(2, "Казань", urgent=True)` → `560` (срочная доставка: 500 + 30*2)
        -   `calculate_delivery(weight=1, city="СПб")` → `320`
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `calculate_delivery`.
        -   Параметры по порядку: `weight` (вес в кг), `city` (название города), `urgent` (флаг срочности, по умолчанию `False`).
        -   Формула: если `urgent` равен `True`, стоимость = `500 + 30 * weight`. Иначе: `300 + 20 * weight`.
        -   Функция должна возвращать число (результат расчета), а не печатать его.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `calculate_delivery` с тремя параметрами: `weight`, `city`, `urgent` (последнему присвой значение по умолчанию `False`).
        2.  Внутри функции проверь значение параметра `urgent`.
        3.  Если `urgent` истинно, вычисли результат по формуле для срочной доставки.
        4.  Иначе, вычисли результат по формуле для стандартной доставки.
        5.  Верни вычисленный результат с помощью оператора `return`.
    -   **Рекомендации:**
        -   **PEP8:** Имя функции должно быть в `snake_case`. После запятой в списке параметров ставь пробел. Длина строки кода не должна превышать 79 символов.

2.  **Безопасное добавление заметок в список**
    -   **Описание задачи:** Ты создаешь приложение для заметок. Нужно написать функцию, которая добавляет новую заметку в список. Важно избежать распространенной ошибки с изменяемым значением по умолчанию (общий список для всех вызовов). Это упражнение учит безопасно работать с параметрами по умолчанию, используя паттерн с `None`.
    -   **Пример (вход → выход):**
        -   `add_note("Купить молоко")` → `['Купить молоко']`
        -   `add_note("Позвонить маме")` → `['Позвонить маме']` (Новый список, а не `['Купить молоко', 'Позвонить маме']`)
        -   `my_notes = ["Задача 1"]; add_note("Задача 2", my_notes)` → `['Задача 1', 'Задача 2']` (Работа с переданным списком)
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `add_note`.
        -   Параметры: `note_text` (текст заметки, обязательный), `notes_list` (список для добавления, по умолчанию `None`).
        -   Если `notes_list` равен `None`, внутри функции нужно создать новый пустой список.
        -   Добавить `note_text` в список `notes_list`.
        -   Функция должна возвращать измененный (или созданный) список.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `add_note` с параметрами `note_text` и `notes_list` (значение по умолчанию — `None`).
        2.  Внутри функции проверь, равен ли `notes_list` `None`.
        3.  Если да, создай новый пустой список и присвой его переменной `notes_list`.
        4.  Добавь (`append`) `note_text` в список `notes_list`.
        5.  Верни список `notes_list`.
    -   **Рекомендации:**
        -   Для проверки на `None` используй оператор `is` (`if notes_list is None:`).
        -   **PEP8:** Используй отступ в 4 пробела для тела функции и блоков `if`.

3.  **Сбор информации о студенте с помощью `*args` и `**kwargs`**
    -   **Описание задачи:** Ты разрабатываешь систему учета студентов. Нужно создать функцию, которая формирует словарь с информацией о студенте. Функция принимает обязательное имя, произвольное количество оценок (`*args`) и произвольные дополнительные данные (`**kwargs`), например, возраст или город. Это упражнение тренирует использование `*args` для переменного числа аргументов и `**kwargs` для произвольных именованных аргументов.
    -   **Пример (вход → выход):**
        -   `build_student("Анна", 5, 4, 5, age=20)` → `{'name': 'Анна', 'grades': (5, 4, 5), 'age': 20}`
        -   `build_student("Борис", 3, 4, city="Москва", hobby="шахматы")` → `{'name': 'Борис', 'grades': (3, 4), 'city': 'Москва', 'hobby': 'шахматы'}`
        -   `build_student("Виктор")` → `{'name': 'Виктор', 'grades': ()}` (кортеж пуст)
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `build_student`.
        -   Параметры: `name` (обязательный), `*grades`, `**details`.
        -   Функция должна возвращать словарь с ключами: `'name'` (строка), `'grades'` (кортеж из переданных оценок) и всеми остальными переданными именованными аргументами (из `**details`).
    -   **Решение (псевдокод):**
        1.  Объяви функцию `build_student` с параметрами `name`, `*grades`, `**details`.
        2.  Внутри функции создай пустой словарь `student_info`.
        3.  Добавь в словарь пару `'name': name`.
        4.  Добавь в словарь пару `'grades': grades` (параметр `*grades` уже является кортежем).
        5.  Обнови (`update`) словарь `student_info` словарем `details`.
        6.  Верни словарь `student_info`.
    -   **Рекомендации:**
        -   Помни, что `*grades` собирает все лишние позиционные аргументы в кортеж, а `**details` — все лишние именованные в словарь.
        -   **PEP8:** Параметры `*args` и `**kwargs` — это общепринятые имена, но в контексте задачи лучше использовать `*grades` и `**details`.

4.  **Локальный счетчик и глобальный лог**
    -   **Описание задачи:** Ты моделирую работу простого счетчика событий. Нужно создать функцию, которая увеличивает свой собственный внутренний счетчик (локальная переменная) и также обновляет глобальный счетчик всех событий. Это упражнение помогает понять разницу между локальной и глобальной областью видимости и учит аккуратно использовать ключевое слово `global`.
    -   **Пример (вход → выход):**
        -   Глобальная переменная `total_events = 0` объявлена до функций.
        -   `event_counter()` → `1` (локальный счетчик этой функции = 1, `total_events = 1`)
        -   `event_counter()` → `2` (локальный счетчик этой функции = 2, `total_events = 2`)
        -   `event_counter()` → `3` (локальный счетчик этой функции = 3, `total_events = 3`)
        -   После трех вызовов, значение `total_events` равно 3.
    -   **Критерии проверки и ограничения:**
        -   Объяви глобальную переменную `total_events = 0` в начале программы (вне функций).
        -   Функция `event_counter` не принимает аргументов.
        -   Внутри функции должна быть своя локальная переменная-счетчик (например, `my_count`), которая сохраняет свое значение между вызовами (используй изменяемый объект, например, список с одним числом, или изучи идею замыкания из урока, но не обязательно ее реализовывать сложно).
        -   Функция должна увеличивать на 1 и локальный счетчик, и глобальную переменную `total_events`.
        -   Функция должна возвращать значение своего локального счетчика.
    -   **Решение (псевдокод):**
        1.  В начале кода создай глобальную переменную `total_events` и присвой ей 0.
        2.  Объяви функцию `event_counter`.
        3.  Внутри функции с помощью `global` объяви, что будешь использовать глобальную переменную `total_events`.
        4.  Создай локальную переменную-список, например, `my_count = [0]`. Это позволит изменять ее содержимое между вызовами.
        5.  Увеличь первый (и единственный) элемент списка `my_count` на 1.
        6.  Увеличь глобальную переменную `total_events` на 1.
        7.  Верни первый элемент списка `my_count` (текущее значение локального счетчика).
    -   **Рекомендации:**
        -   Использование списка `[0]` — это один из простых способов создать изменяемую переменную, состояние которой сохраняется между вызовами функции (так как список — изменяемый объект).
        -   **PEP8:** Использование `global` — это особый случай. Убедись, что оператор `global total_events` находится в начале тела функции. Избегай излишнего использования `global` в будущем, возвращая значения.
